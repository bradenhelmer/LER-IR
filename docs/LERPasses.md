<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `-convert-array-acc-to-memref`

_Creates actual memref arrays from ler.ArrayAccesses._

Due to LER notation containing array accesses that don't have any corresponding
array declarations to actually access, these must be created using
`memref.Alloc` operations. The sizes of these arrays will never be more
than 6 dimensions, or more than 1 million total items. For example, an
access that is one dimensional like `x[i]` will have an array  created like so:

	%0 = memref.alloc() : memref<100000xi64>	
Next, the `ler.ArrayAccess` operations will be lowered into `memref.Load`
operations. A module before this pass may look like:
```mlir
"builtin.module"() <{sym_name = "../test/case10.ler"}> ({
  "func.func"() <{function_type = () -> (), sym_name = "main"}> ({
	"ler.RegularFor"() <{LoopIdxVar = "i", LowerBound = 1 : i64, Step = 1 : i64, UpperBound = @M}> ({
	^bb0(%arg0: index):
	  "ler.Summation"() <{LoopIdxVar = "k", LowerBound = 0 : i64, Step = 1 : i64, UpperBound = @i}> ({
	  ^bb0(%arg1: index):
		"ler.Summation"() <{LoopIdxVar = "j", LowerBound = 0 : i64, Step = 1 : i64, UpperBound = @i}> ({
		^bb0(%arg2: index):
		  %0 = "ler.Variable"() <{Name = @i}> : () -> i64
		  %1 = "ler.Variable"() <{Name = @j}> : () -> i64
		  %2 = "ler.ArrayAccess"(%0, %1) <{ArrayName = @x}> : (i64, i64) -> i64
		  %3 = "ler.Variable"() <{Name = @j}> : () -> i64
		  %4 = "ler.Variable"() <{Name = @k}> : () -> i64
		  %5 = "ler.ArrayAccess"(%3, %4) <{ArrayName = @y}> : (i64, i64) -> i64
		  %6 = "ler.Mul"(%2, %5) : (i64, i64) -> i64
		  %7 = "ler.Variable"() <{Name = @i}> : () -> i64
		  %8 = "ler.ArrayAccess"(%7) <{ArrayName = @r}> : (i64) -> i64
		  "ler.Result"(%6, %8) : (i64, i64) -> ()
		}) : () -> ()
	  }) : () -> ()
	}) : () -> ()
  }) : () -> ()
```
After:
```mlir
module @"../test/case10.ler" attributes {ler.Source = "^Ri|1,M|^Sk|0,i|^Sj|0,i|x[i,j] * y[j,k] = r[i]\0A\0A"} {
 func.func @main() {
   %alloc = memref.alloc() : memref<1000000xi64>
   %alloc_0 = memref.alloc() : memref<1000x1000xi64>
   %alloc_1 = memref.alloc() : memref<1000x1000xi64>
   "ler.RegularFor"() <{LoopIdxVar = "i", LowerBound = 1 : i64, Step = 1 : i64, UpperBound = @M}> ({
   ^bb0(%arg0: index):
     "ler.Summation"() <{LoopIdxVar = "k", LowerBound = 0 : i64, Step = 1 : i64, UpperBound = @i}> ({
     ^bb0(%arg1: index):
       "ler.Summation"() <{LoopIdxVar = "j", LowerBound = 0 : i64, Step = 1 : i64, UpperBound = @i}> ({
       ^bb0(%arg2: index):
         %0 = memref.load %alloc_1[%arg0, %arg2] : memref<1000x1000xi64>
         %1 = memref.load %alloc_0[%arg2, %arg1] : memref<1000x1000xi64>
         %2 = "ler.Mul"(%0, %1) : (i64, i64) -> i64
         %3 = memref.load %alloc[%arg0] : memref<1000000xi64>
         "ler.Result"(%2, %3) : (i64, i64) -> ()
		}) : () -> ()
	  }) : () -> ()
	}) : () -> ()
  }
}
```
**NOTE**: This pass assumes the the `-inject-induction-vars` pass has ran before.
### `-convert-for-to-affine`

_Converts ler.[Production|Regular|Summartion]ForLoops to affine.for. This pass also converts ler.WhileLoops to SCF.while._

This pass takes LER loop operations and lowers them into intermediary dialects
before into LLVM. All of the LER for loop operatons (Production|Regular|Summartion)
are lowered into `affine.For` operations and `ler.WhileLoop` are lowered into
`scf.While` operations. When lowering into `affine.For` operations, affine mappings
are created during runtime to ensure all of the created arrays are not accessed
out of bounds. When converting `ler.While` operations, a simple counter is implemented
to act as the condition for the loop, giving a constant iteration count. This pass 
also converts `ler.Result` ops to `memref.Store` and `ler.Variable` ops to 
`arith.Constant`. Module before:

```mlir
"builtin.module"() <{sym_name = "../test/case10.ler"}> ({
   "func.func"() <{function_type = () -> (), sym_name = "main"}> ({
   "ler.RegularFor"() <{LoopIdxVar = "i", LowerBound = 1 : i64, Step = 1 : i64, UpperBound = @M}> ({
   ^bb0(%arg0: index):
     "ler.Summation"() <{LoopIdxVar = "k", LowerBound = 0 : i64, Step = 1 : i64, UpperBound = @i}> ({
     ^bb0(%arg1: index):
       "ler.Summation"() <{LoopIdxVar = "j", LowerBound = 0 : i64, Step = 1 : i64, UpperBound = @i}> ({
       ^bb0(%arg2: index):
         %0 = "ler.Variable"() <{Name = @i}> : () -> i64
         %1 = "ler.Variable"() <{Name = @j}> : () -> i64
         %2 = "ler.ArrayAccess"(%0, %1) <{ArrayName = @x}> : (i64, i64) -> i64
         %3 = "ler.Variable"() <{Name = @j}> : () -> i64
         %4 = "ler.Variable"() <{Name = @k}> : () -> i64
         %5 = "ler.ArrayAccess"(%3, %4) <{ArrayName = @y}> : (i64, i64) -> i64
         %6 = "ler.Mul"(%2, %5) : (i64, i64) -> i64
         %7 = "ler.Variable"() <{Name = @i}> : () -> i64
         %8 = "ler.ArrayAccess"(%7) <{ArrayName = @r}> : (i64) -> i64
         "ler.Result"(%6, %8) : (i64, i64) -> ()
		}) : () -> ()
	  }) : () -> ()
	}) : () -> ()
  }) : () -> ()
}) {ler.Source = "^Ri|1,M|^Sk|0,i|^Sj|0,i|x[i,j] * y[j,k] = r[i]\0A\0A"} : () -> ()
```
Module after:
```mlir
module @"../test/case10.ler" attributes {ler.Source = "^Ri|1,M|^Sk|0,i|^Sj|0,i|x[i,j] * y[j,k] = r[i]\0A\0A"} {
  func.func @main() {
	affine.for %arg0 = 1 to 1000000 {
	  affine.for %arg1 = 0 to 1000000 {
		affine.for %arg2 = 0 to 1000000 {
		  %0 = "ler.ArrayAccess"(%arg0, %arg2) <{ArrayName = @x}> : (index, index) -> i64
		  %1 = "ler.ArrayAccess"(%arg2, %arg1) <{ArrayName = @y}> : (index, index) -> i64
		  %2 = "ler.Mul"(%0, %1) : (i64, i64) -> i64
		  %3 = "ler.ArrayAccess"(%arg0) <{ArrayName = @r}> : (index) -> i64
		}
	  }
	}
	return
  }
}
```

**NOTE**: This pass assumes the the `-inject-induction-vars` pass has ran before.


### `-convert-to-arith`

_Converts existing ler.Variables to arith.Constants and binary ops to their respectivearith counterparts_

### `-convert-to-llvm`

_Converts all intermediary dialects (affine, arith, memref, scf) to llvm_

### `-inject-induction-vars`

_Replaces ler.Variable references with their respective loop index variables (block arguments)._

